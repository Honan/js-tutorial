# Создание объектов и прототипов

В JavaScript можно создавать конструктор для объекта. Как и в других объектно-ориентированных языках программирования вроде Java и С++, в JavaScript реализована операция `new`, предназначена для получения экземпляров новых объектов через конструкторы, но в то же время в JavaScript отсутствует определение класса как таковое.

У каждой функции есть свой объект-прототип, который автоматически задается в качестве прототипа объектов.

```javascript
function fn(){ // определяем функцию, которая ничего не делает и не возвращает
    fn.prototype.boolean = function(){ // у каждой функции имеется встроенный объект-прототип, который можно свободно видоизменять
        return true;
    }
};

const foo = fn(); // можно вызвать как обычную функцию, при этом ничего особенного не происходит

const bar = new fn(); // а можно вызвать как конструктор. При этом создается новый экземпляр объекта, получающий метод из прототипа функции
console.log(bar.boolean()); // true
```

Когда функция вызывается как конструктор в операции `new`, в качестве ее контекста устанавливается новый экземпляр объекта. Это означает, что, помимо доступности свойств через прототип, имеется также возможность инициализировать значения новых свойств в функции-конструкторе через параметр `this`.

```javascript
function Fn(){
    this.swung = false; // создать переменную экземпляра, инициализируемую логическим значением false
    this.boolean = function(){ // создать метод экземпляра, возвращающий обратное значенте переменной экземпляра swung
        return !this.swung;
    }
};

Fn.prototype.boolean = function(){ // Определить метод прототипа с тем же именем, что и у метода экземпляра.
    return this.swung;
}

const obj = new Fn();
console.log(obj.boolean()); // true

```

Мы задали свойства в конструкторе и в прототипе с одинаковым именем и пытаемся это свойство вызвать. Консоль нам показывает, что члены экземпляра объекта, создаваемые в конструкторе, перекрывают одноименные свойства, определяемые в прототип. Т.е. сначала смотрится свойство в объекте, если нет такого свойства, интерпретатор ищет в прототипе и т.д.
